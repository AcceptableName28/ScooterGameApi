<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scooter Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #222;
    overflow: hidden;
    height: 100%;
    font-family: sans-serif;
    color: white;
  }
  canvas {
    display: block;
    background: #333;
    margin: 0 auto;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2;
    text-align: center;
  }
  #scoreboard {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    padding: 1em;
    border-radius: 10px;
  }
  @media (max-width: 768px) {
    canvas {
      width: 100vw;
      height: calc(var(--app-vh, 100vh) - 16px);
      aspect-ratio: auto;
    }
  }
</style>
</head>
<body>
<div id="ui">
  <h1>üèç Scooter Game</h1>
  <div id="score">Score: 0</div>
</div>
<canvas id="gameCanvas"></canvas>
<div id="scoreboard">
  <h2>Game Over</h2>
  <p>Your Score: <span id="finalScore"></span></p>
  <input type="text" id="playerName" placeholder="Enter your name">
  <button id="submitScore">Submit Score</button>
  <button id="restartBtn">Restart</button>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W = 960, H = 540;
let floorY = H * 0.78;

function updateGeometry(cssW, cssH) {
  W = Math.max(1, Math.round(cssW));
  H = Math.max(1, Math.round(cssH));
  floorY = H * 0.78;
  if (player) {
    if (player.y > floorY) player.y = floorY;
  }
}

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth));
  const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight));
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width  = cssW * DPR;
  canvas.height = cssH * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = true;
  updateGeometry(cssW, cssH);
}

function setAppVh() {
  const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
  document.documentElement.style.setProperty('--app-vh', vh + 'px');
}
setAppVh();
window.addEventListener('resize', setAppVh);
if (window.visualViewport) window.visualViewport.addEventListener('resize', setAppVh);

window.addEventListener('resize', resizeCanvas);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeCanvas);

// Game variables
let player = { x: 100, y: floorY, vy: 0, size: 40, onGround: true };
let obstacles = [];
let score = 0;
let gameOver = false;
let speed = 6;
let obstacleSpacing = 2000; // ms between spawns
let lastSpawn = 0;

function jump(){
  if (player.onGround) {
    player.vy = -12;
    player.onGround = false;
  }
}

document.addEventListener('keydown', e => {
  if (e.code === 'Space') jump();
});
document.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameOver) return;
  jump();
}, { passive: false });

document.getElementById('restartBtn').addEventListener('click', restartGame);
document.getElementById('submitScore').addEventListener('click', submitScore);

function submitScore(){
  const name = document.getElementById('playerName').value.trim();
  if (!name) return;
  fetch('https://scooter-game-api.vercel.app/api/leaderboard', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, score })
  }).then(() => restartGame());
}

function restartGame(){
  player = { x: 100, y: floorY, vy: 0, size: 40, onGround: true };
  obstacles = [];
  score = 0;
  speed = 6;
  lastSpawn = 0;
  gameOver = false;
  document.getElementById('scoreboard').style.display = 'none';
}

function spawnObstacle(){
  const size = 40;
  obstacles.push({ x: W, y: floorY, size });
}

function update(delta){
  if (gameOver) return;

  // Gravity
  player.vy += 0.6;
  player.y += player.vy;
  if (player.y >= floorY) {
    player.y = floorY;
    player.vy = 0;
    player.onGround = true;
  }

  // Spawn obstacles
  if (Date.now() - lastSpawn > obstacleSpacing) {
    spawnObstacle();
    lastSpawn = Date.now();
  }

  // Move obstacles
  for (let obs of obstacles) {
    obs.x -= speed;
    if (obs.x + obs.size < 0) {
      obstacles.shift();
      score++;
      if (score % 5 === 0) speed += 0.5;
    }
    // Collision
    if (player.x < obs.x + obs.size &&
        player.x + player.size > obs.x &&
        player.y < obs.y &&
        player.y + player.size > obs.y - obs.size) {
      gameOver = true;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('scoreboard').style.display = 'block';
    }
  }
}

function draw(){
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'lightblue';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = 'green';
  ctx.fillRect(0, floorY + player.size, W, H - floorY);

  ctx.fillStyle = 'red';
  ctx.fillRect(player.x, player.y - player.size, player.size, player.size);

  ctx.fillStyle = 'black';
  for (let obs of obstacles) {
    ctx.beginPath();
    ctx.moveTo(obs.x, obs.y);
    ctx.lineTo(obs.x + obs.size, obs.y);
    ctx.lineTo(obs.x + obs.size/2, obs.y - obs.size);
    ctx.closePath();
    ctx.fill();
  }

  document.getElementById('score').textContent = 'Score: ' + score;
}

let lastTime = 0;
function loop(timestamp){
  const delta = timestamp - lastTime;
  lastTime = timestamp;
  update(delta);
  draw();
  requestAnimationFrame(loop);
}

resizeCanvas();
loop();
</script>
</body>
</html>