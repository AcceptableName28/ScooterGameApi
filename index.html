<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Scooter Game</title>
<style>
  :root { --app-vh: 100vh; }

  body{
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    background: #f0f2f5;
    color: #111;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
  }

  #gameContainer{
    position: relative;
    margin: 0 auto;
    display: grid;
    place-items: center;
    height: 100vh; /* desktop fallback; mobile uses --app-vh */
  }

  canvas{
    background: #fff;
    border: 2px solid #000;
    border-radius: 10px;
    display: block;
    width: 960px;
    height: 540px;
    max-width: 100vw;
    touch-action: manipulation;
  }

  /* Compact UI bar for Start/Restart */
  #ui{
    position: absolute;
    top: 8px; left: 50%;
    transform: translateX(-50%);
    z-index: 5;
    display: flex; gap: 8px;
    pointer-events: none;
  }
  #ui button{
    pointer-events: auto;
    font-weight: 800;
    border-radius: 10px;
    padding: 8px 14px;
    border: 0;
    background: #111;
    color: #fff;
  }

  /* Game Over overlay with initials + Top 10 */
  #scoreboard{
    position: fixed; inset: 0;
    display: none;
    align-items: center; justify-content: center;
    background: rgba(255,255,255,.9);
    z-index: 10;
    overflow: auto;
    padding: 16px 0;
  }
  .card{
    background: #fff; border-radius: 14px;
    box-shadow: 0 12px 36px rgba(0,0,0,.2);
    padding: 20px 24px;
    width: min(92vw, 520px);
  }
  .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
  .btn{ background:#111; color:#fff; padding:10px 16px; border-radius:10px; font-weight:800; border:0; }
  .muted{ opacity:.7; }
  input.initials{
    width:160px; text-align:center; font-size:28px; letter-spacing:6px; text-transform:uppercase;
    border:2px solid #111; border-radius:10px; padding:8px 10px; outline:none;
  }
  ol.lb{ margin:8px 0 0 20px; padding:0; }
  ol.lb li{ display:flex; justify-content:space-between; font-weight:700; }

  /* Mobile: robust height with fallbacks so canvas never collapses */
  @media (max-width: 768px){
    #gameContainer{ height: var(--app-vh, 100vh); }
    canvas{
      width: 100vw;
      height: calc( max(60vh, var(--app-vh, 100vh)) - 20px );
      min-height: 300px;
      max-height: 100vh;
      aspect-ratio: auto;
    }
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="960" height="540"></canvas>

  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="restartBtn" style="display:none;">Restart</button>
  </div>
</div>

<!-- Game Over + initials + TOP 10 -->
<div id="scoreboard">
  <div class="card">
    <h2 style="margin:0 0 8px">Game Over</h2>
    <div style="margin-bottom:8px">Score: <b id="finalScore">0</b></div>

    <div id="qualifyBox" style="display:block">
      <div style="display:flex;justify-content:center;margin:8px 0">
        <input id="playerName" class="initials" maxlength="3" placeholder="AAA" autocomplete="off" spellcheck="false">
      </div>
      <div class="muted" style="text-align:center">Enter 3 letters/numbers ¬∑ Only A‚ÄìZ / 0‚Äì9</div>
      <div class="row">
        <button id="submitScore" class="btn">Save</button>
        <button id="skipBtn" class="btn" style="background:#666">Skip</button>
      </div>
    </div>

    <div style="margin-top:14px">
      <div style="font-weight:800; margin-bottom:6px">üèÅ Top 10</div>
      <ol id="lb" class="lb"></ol>
      <div id="lbSub" class="muted">Loading‚Ä¶</div>
    </div>

    <div class="row" style="margin-top:14px">
      <button id="goRestartBtn" class="btn">Restart (R)</button>
    </div>
  </div>
</div>

<script>
/* ================= Mobile real viewport height (robust) ================= */
function setAppVhOnce(){
  const vv = window.visualViewport;
  const h = vv && vv.height ? vv.height : window.innerHeight || document.documentElement.clientHeight || 0;
  if (h > 0) document.documentElement.style.setProperty('--app-vh', h + 'px');
}
function pumpVhUpdates(){
  setAppVhOnce();
  requestAnimationFrame(setAppVhOnce);
  setTimeout(setAppVhOnce, 60);
}
pumpVhUpdates();
addEventListener('resize', pumpVhUpdates, { passive:true });
addEventListener('orientationchange', pumpVhUpdates, { passive:true });
addEventListener('pageshow', pumpVhUpdates, { passive:true });
if (window.visualViewport) window.visualViewport.addEventListener('resize', pumpVhUpdates, { passive:true });

/* ================= Canvas + DPR scaling ================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  let cssW = Math.max(1, Math.floor(rect.width || window.innerWidth));
  let cssH = Math.max(1, Math.floor(rect.height || window.innerHeight));
  if (cssH < 120) {
    const vh = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--app-vh')) || window.innerHeight || 540;
    cssH = Math.max(300, Math.floor(vh - 20));
  }
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width  = cssW * DPR;
  canvas.height = cssH * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  W = cssW; H = cssH; floorY = H * 0.78;
  if (player && player.y > floorY) player.y = floorY;
}
addEventListener('load', () => { pumpVhUpdates(); resizeCanvas(); });
addEventListener('pageshow', () => { pumpVhUpdates(); resizeCanvas(); });
addEventListener('resize', resizeCanvas);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeCanvas);

/* ================= Game state ================= */
let W = 960, H = 540;
let floorY = H * 0.78;

const world = {
  // slow, enjoyable difficulty via speed only
  speed: 6,
  baseSpeed: 6,
  maxSpeed: 13.5,
  score: 0,
  alive: false,

  // distance until next spawn (pixels) ‚Äì computed each spawn
  spawnDist: 600,

  // RANDOM obstacle mix with anti‚Äëstreak rules
  pTallBase: 0.32,
  pTallLate: 0.42,
  tallStreak: 0,
  singleStreak: 0,
  maxTallStreak: 2,
  maxSingleStreak: 3,

  // snappy rhythm: target reaction times (seconds)
  rtSingle: 0.90,
  rtTall:   1.05,
  rtJitter: 0.10,

  // long, gentle ramp settings
  warmupScore: 500,
  rampRate:   0.00125
};

const player = { x: 120, y: floorY, vy: 0, w: 120, h: 80, onGround: true };
const obstacles = [];
const TRI_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#8338ec','#ef476f','#f9c74f','#90be6d'];

/* ---- Jump physics (updated for easier early double-jumps) ---- */
const gravity   = 0.90;
const JUMP_VEL_1 = -14.8; // tiny boost
const JUMP_VEL_2 = -13.2; // more hang time
const COYOTE_FRAMES = 8;
const BUFFER_FRAMES = 10;

let coyote = 0, jumpBuffer = 0, usedDouble = false;

/* ================= Vespa sprite ================= */
const vespaImg = new Image();
let vespaReady = false;
vespaImg.onload = () => vespaReady = true;
vespaImg.src = 'Blue Vespa Right.png'; // must exist next to this file

/* ================= UI refs ================= */
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

const scoreboard = document.getElementById('scoreboard');
const finalScoreEl = document.getElementById('finalScore');
const initialsEl = document.getElementById('playerName');
const submitBtn = document.getElementById('submitScore');
const skipBtn = document.getElementById('skipBtn');
const goRestartBtn = document.getElementById('goRestartBtn');
const lbEl = document.getElementById('lb');
const lbSub = document.getElementById('lbSub');

/* ================= Leaderboard API ================= */
const API = 'https://scooter-game-api.vercel.app';
async function getTop10(){
  try{
    const r = await fetch(`${API}/api/leaderboard`, { cache: 'no-store' });
    if(!r.ok) return [];
    return await r.json();
  }catch{ return []; }
}
async function saveScore(name, score){
  const r = await fetch(`${API}/api/leaderboard`, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ name, score })
  });
  const txt = await r.text(); let data=null; try{ data = txt?JSON.parse(txt):null; }catch{}
  if(!r.ok) throw new Error(data?.error || txt || 'save failed');
  return data;
}
function renderLB(list){
  lbEl.innerHTML = '';
  list.forEach((e,i)=>{
    const li = document.createElement('li');
    const name = (e.name||'---').toUpperCase().slice(0,3);
    li.innerHTML = `<span>${i+1}.) ${name}</span><span>${e.score}</span>`;
    lbEl.appendChild(li);
  });
  lbSub.textContent = list.length ? 'Global leaderboard' : 'No scores yet ‚Äî be the first!';
}

/* ================= Difficulty ramp ================= */
function speedForScore(s) {
  if (s < world.warmupScore) return world.baseSpeed;
  const span = world.maxSpeed - world.baseSpeed;
  const t = s - world.warmupScore;
  return world.baseSpeed + span * (1 - Math.exp(-world.rampRate * t));
}

/* ================= Spawn helpers (random but fair) ================= */
function decideTall(score) {
  // blend toward late-game probability
  const lateBlend = Math.min(1, Math.max(0, (score - world.warmupScore) / 1500));
  let pTall = world.pTallBase * (1 - lateBlend) + world.pTallLate * lateBlend;

  // anti‚Äëstreak
  if (world.tallStreak   >= world.maxTallStreak)   return false;
  if (world.singleStreak >= world.maxSingleStreak) return true;

  return Math.random() < pTall;
}

/* ---- Tall height scales with score (easier at start, tougher later) ---- */
function chooseTriangleSpec(isTall) {
  const s = world.score;

  // Single-jump band unchanged
  const smallHmin = 52,  smallHmax = 92;

  // Tall band ramps with score: starts easier, reaches full height by ~2000 score
  const tallRamp = Math.min(1, Math.max(0, s / 2000));
  const tallHmin0 = 100, tallHmax0 = 130; // early game (easier)
  const tallHmin1 = 112, tallHmax1 = 160; // later game

  const tallHmin = tallHmin0 + (tallHmin1 - tallHmin0) * tallRamp;
  const tallHmax = tallHmax0 + (tallHmax1 - tallHmax0) * tallRamp;

  const height = isTall
    ? tallHmin  + Math.random() * (tallHmax  - tallHmin)
    : smallHmin + Math.random() * (smallHmax - smallHmin);

  const base = 44 + Math.random() * 54; // variety
  return { base, height };
}

/* ---- Keep reaction time fair; extra gap for tall triangles at low speed ---- */
function planNextSpawnDistance(currentSpeed, isTall) {
  const rtBase = isTall ? world.rtTall : world.rtSingle;
  const jitter = (Math.random()*2 - 1) * world.rtJitter;
  const rt = Math.max(0.65, rtBase + jitter);

  let margin = 70 + currentSpeed * 5; // base margin scales with speed

  // Extra room for tall triangles when speed is low to finish the double-jump arc
  if (isTall && currentSpeed < 8) {
    const ease = (8 - currentSpeed) / 4;            // 0..0.5 roughly
    margin += 80 * Math.max(0, Math.min(1, ease));  // up to +80px
  }

  // distance ‚âà speed(px/frame) * frames + margin
  return Math.max(240, currentSpeed * (rt * 60) + margin);
}

function spawnTriangle(){
  const isTall = decideTall(world.score);
  const spec = chooseTriangleSpec(isTall);
  const color = TRI_COLORS[(Math.random()*TRI_COLORS.length)|0];
  obstacles.push({ x: W + 40, y: floorY, base: spec.base, height: spec.height, color });

  // update streaks
  if (isTall) { world.tallStreak++; world.singleStreak = 0; }
  else        { world.singleStreak++; world.tallStreak  = 0; }

  // schedule next gap
  world.spawnDist = planNextSpawnDistance(world.speed, isTall);
}

/* ================= Collision helpers ================= */
function getPlayerBounds(){
  // tighter Vespa: ~76% width, ~78% height, lifted slightly
  const w = player.w * 0.76;
  const h = player.h * 0.78;
  const x = player.x - w/2;
  const y = (player.y - player.h) + (player.h - h) - 4;
  return { x, y, w, h };
}
function triTopY(tri, x){
  const x0 = tri.x, x2 = tri.x + tri.base;
  if (x <= x0 || x >= x2) return Infinity;
  const xc = (x0 + x2) * 0.5;
  const dx = Math.abs(x - xc);
  const t = 1 - (dx / (tri.base * 0.5));  // 0 at edges -> 1 center
  return tri.y - tri.height * Math.max(0, Math.min(1, t));
}
function rectHitsTriangle(rect, tri){
  if (rect.x + rect.w <= tri.x || rect.x >= tri.x + tri.base) return false;
  const xFront = Math.min(rect.x + rect.w, tri.x + tri.base - 0.5);
  const xMid   = Math.max(rect.x + rect.w - 10, rect.x + rect.w * 0.5);
  const xBack  = Math.max(rect.x + 6, rect.x);
  const yTopF = triTopY(tri, xFront);
  const yTopM = triTopY(tri, xMid);
  const yTopB = triTopY(tri, xBack);
  const yBottom = rect.y + rect.h;
  return (yBottom > yTopF) || (yBottom > yTopM) || (yBottom > yTopB);
}

/* ================= Control ================= */
function reset(){
  world.score = 0;
  world.speed = world.baseSpeed;
  world.spawnDist = 600;
  world.tallStreak = 0;
  world.singleStreak = 0;
  obstacles.length = 0;
  player.x = Math.max(120, 0.18 * W);
  player.y = floorY; player.vy = 0; player.onGround = true;
  coyote = 0; jumpBuffer = 0; usedDouble = false;
}
function startGame(){
  reset();
  world.alive = true;
  startBtn.style.display = 'none';
  restartBtn.style.display = 'none';
  scoreboard.style.display = 'none';
}
function endGame(){
  world.alive = false;
  finalScoreEl.textContent = Math.floor(world.score);
  initialsEl.value = '';
  scoreboard.style.display = 'flex';
  lbSub.textContent = 'Loading‚Ä¶';
  getTop10().then(renderLB);
}

/* ================= Input ================= */
document.addEventListener('keydown', (e)=>{
  if(e.code==='Space' || e.keyCode===38){
    e.preventDefault();
    if(!world.alive){ startGame(); return; }
    jumpBuffer = BUFFER_FRAMES;
  }else if(e.code==='KeyR'){
    e.preventDefault();
    startGame();
  }
});
canvas.addEventListener('pointerdown', (e)=>{
  if(e.pointerType==='mouse') return;
  if(!world.alive){ e.preventDefault(); startGame(); return; }
  e.preventDefault(); jumpBuffer = BUFFER_FRAMES;
}, { passive:false });
canvas.addEventListener('touchstart', (e)=>{
  if(!world.alive){ e.preventDefault(); startGame(); return; }
  e.preventDefault(); jumpBuffer = BUFFER_FRAMES;
}, { passive:false });

function startFromUI(e){ if(e) e.preventDefault(); startGame(); }
function restartFromUI(e){ if(e) e.preventDefault(); startGame(); }
startBtn.addEventListener('click', startFromUI);
startBtn.addEventListener('pointerdown', startFromUI, { passive:false });
startBtn.addEventListener('touchstart', startFromUI, { passive:false });
restartBtn.addEventListener('click', restartFromUI);
restartBtn.addEventListener('pointerdown', restartFromUI, { passive:false });
restartBtn.addEventListener('touchstart', restartFromUI, { passive:false });
goRestartBtn.addEventListener('click', restartFromUI);
goRestartBtn.addEventListener('pointerdown', restartFromUI, { passive:false });
goRestartBtn.addEventListener('touchstart', restartFromUI, { passive:false });

/* Initials constraints + save/skip */
function sanitizeInitials(s){ return (s||'').toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,3); }
initialsEl.addEventListener('input', ()=>{
  const clean = sanitizeInitials(initialsEl.value);
  if(initialsEl.value !== clean) initialsEl.value = clean;
});
submitBtn.addEventListener('click', async ()=>{
  const name = sanitizeInitials(initialsEl.value);
  if(!name){ scoreboard.style.display='none'; return; }
  try{
    submitBtn.textContent='Saving‚Ä¶'; submitBtn.disabled=true;
    await saveScore(name, Math.floor(world.score));
    const lb = await getTop10(); renderLB(lb);
  }catch(err){ alert('Save failed: ' + (err.message||err)); }
  finally{ submitBtn.textContent='Save'; submitBtn.disabled=false; }
});
skipBtn.addEventListener('click', ()=>{ scoreboard.style.display='none'; });

/* ================= Game loop ================= */
function update(){
  // Slow, long difficulty ramp
  world.speed = Math.min(world.maxSpeed, speedForScore(world.score));

  if(world.alive){
    // Jump logic (coyote + buffer + double)
    if(player.onGround) coyote = COYOTE_FRAMES; else if(coyote>0) coyote--;
    if(jumpBuffer>0) jumpBuffer--;
    if(jumpBuffer>0 && (player.onGround || coyote>0)){
      player.vy = JUMP_VEL_1; player.onGround=false; usedDouble=false; jumpBuffer=0;
    } else if(jumpBuffer>0 && !player.onGround && !usedDouble){
      player.vy = JUMP_VEL_2; usedDouble=true; jumpBuffer=0;
    }

    // Gravity
    player.vy += gravity; player.y += player.vy;
    if(player.y >= floorY){ player.y=floorY; player.vy=0; if(!player.onGround){ player.onGround=true; usedDouble=false; } }
    else { player.onGround=false; }

    // Move obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i]; o.x -= world.speed; if(o.x + o.base < -120) obstacles.splice(i,1);
    }

    // Spawn with reaction‚Äëtime based gaps
    world.spawnDist -= world.speed;
    if(world.spawnDist <= 0){ spawnTriangle(); }

    // Score over time
    world.score += 0.24 + world.speed*0.013;

    // Collision
    const pb = getPlayerBounds();
    for(const o of obstacles){
      const ob = { x:o.x, y:o.y - o.height, w:o.base, h:o.height };
      const bboxOverlap = pb.x < ob.x + ob.w && pb.x + pb.w > ob.x && pb.y < ob.y + ob.h && pb.y + pb.h > ob.y;
      if (bboxOverlap && rectHitsTriangle(pb, o)) { endGame(); break; }
    }
  }

  draw();
  requestAnimationFrame(update);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Sky
  ctx.fillStyle = '#a6d4ff'; ctx.fillRect(0,0,W,H);

  // Road
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, floorY, W, H-floorY);
  ctx.fillStyle = 'rgba(255,255,255,.25)';
  const stripeW=120, stripeH=6, phase=(world.score*0.5)%(stripeW*2);
  for(let x=-phase; x<W; x+=stripeW*2){
    const xx1=Math.round(x), xx2=Math.round(x+60);
    ctx.fillRect(xx1, floorY+30, stripeW, stripeH);
    ctx.fillRect(xx2, floorY+60, stripeW, stripeH);
  }

  // Triangles
  for(const o of obstacles){
    ctx.fillStyle=o.color; ctx.beginPath();
    const x0=Math.round(o.x), y0=Math.round(o.y);
    const x1=Math.round(o.x + o.base/2), y1=Math.round(o.y - o.height);
    const x2=Math.round(o.x + o.base);
    ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y0); ctx.closePath(); ctx.fill();
  }

  // Vespa sprite (fallback to rect while loading)
  if (vespaReady) {
    ctx.drawImage(vespaImg,
      Math.round(player.x - player.w/2),
      Math.round(player.y - player.h),
      player.w, player.h
    );
  } else {
    ctx.fillStyle = '#1e8bff';
    ctx.fillRect(Math.round(player.x - player.w/2), Math.round(player.y - player.h), player.w, player.h);
  }

  // Shadow
  ctx.fillStyle='rgba(0,0,0,.16)';
  ctx.beginPath(); ctx.ellipse(player.x, player.y-2, player.w*0.44, 8, 0, 0, Math.PI*2); ctx.fill();

  // HUD
  ctx.fillStyle='#111'; ctx.font='16px system-ui, sans-serif';
  ctx.fillText(`Score: ${Math.floor(world.score)}`, 12, 22);
}

/* ================= Kickoff ================= */
resizeCanvas();
requestAnimationFrame(update);
</script>
</body>
</html>