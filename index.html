<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>
<title>Scooter Game</title>
<style>
  :root { --app-vh: 100vh; }

  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    background: #f0f2f5;
    color: #111;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
  }

  #gameContainer {
    position: relative;
    margin: 0 auto;
    display: grid;
    place-items: center;
    height: 100vh;
  }

  canvas {
    background: #fff;
    border: 2px solid #000;
    border-radius: 10px;
    display: block;
    width: 960px;
    height: 540px;
    max-width: 100vw;
    touch-action: manipulation;
  }

  /* Compact UI bar for Start/Restart */
  #ui {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 5;
    display: flex;
    gap: 8px;
    pointer-events: none;
  }
  #ui button {
    pointer-events: auto;
    font-weight: 800;
    border-radius: 10px;
    padding: 8px 14px;
    border: 0;
    background: #111;
    color: #fff;
  }

  /* Game Over overlay with initials + Top 10 */
  #scoreboard {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,.9);
    z-index: 10;
    overflow: auto;
    padding: 16px 0;
  }
  .card {
    background: #fff;
    border-radius: 14px;
    box-shadow: 0 12px 36px rgba(0,0,0,.2);
    padding: 20px 24px;
    width: min(92vw, 520px);
  }
  .row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
  .btn { background:#111; color:#fff; padding:10px 16px; border-radius:10px; font-weight:800; border:0; }
  .muted { opacity: .7; }
  input.initials {
    width: 160px;
    text-align: center;
    font-size: 28px;
    letter-spacing: 6px;
    text-transform: uppercase;
    border: 2px solid #111;
    border-radius: 10px;
    padding: 8px 10px;
    outline: none;
  }
  ol.lb { margin: 8px 0 0 20px; padding: 0; }
  ol.lb li { display:flex; justify-content:space-between; font-weight:700; }

  /* Make canvas fill the visible mobile height */
  @media (max-width: 768px) {
    #gameContainer { height: calc(var(--app-vh)); }
    canvas {
      width: 100vw;
      height: calc(var(--app-vh) - 20px);
      max-height: 100vh;
      aspect-ratio: auto;
    }
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="960" height="540"></canvas>

  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="restartBtn" style="display:none;">Restart</button>
  </div>
</div>

<!-- Game Over + initials + TOP 10 -->
<div id="scoreboard">
  <div class="card">
    <h2 style="margin:0 0 8px">Game Over</h2>
    <div style="margin-bottom:8px">Score: <b id="finalScore">0</b></div>

    <div id="qualifyBox" style="display:block">
      <div style="display:flex;justify-content:center;margin:8px 0">
        <input id="playerName" class="initials" maxlength="3" placeholder="AAA" autocomplete="off" spellcheck="false">
      </div>
      <div class="muted" style="text-align:center">Enter 3 letters/numbers ¬∑ Only A‚ÄìZ / 0‚Äì9</div>
      <div class="row">
        <button id="submitScore" class="btn">Save</button>
        <button id="skipBtn" class="btn" style="background:#666">Skip</button>
      </div>
    </div>

    <div style="margin-top:14px">
      <div style="font-weight:800; margin-bottom:6px">üèÅ Top 10</div>
      <ol id="lb" class="lb"></ol>
      <div id="lbSub" class="muted">Loading‚Ä¶</div>
    </div>

    <div class="row" style="margin-top:14px">
      <button id="goRestartBtn" class="btn">Restart (R)</button>
    </div>
  </div>
</div>

<script>
/* ---------- Mobile real viewport height (fix 100vh on iOS/Android) ---------- */
function setAppVh() {
  const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
  document.documentElement.style.setProperty('--app-vh', vh + 'px');
}
setAppVh();
addEventListener('resize', setAppVh);
addEventListener('orientationchange', setAppVh);
if (window.visualViewport) window.visualViewport.addEventListener('resize', setAppVh);

/* ---------- Canvas setup with DPR scaling ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth));
  const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight));
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = cssW * DPR;
  canvas.height = cssH * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  W = cssW; H = cssH; floorY = H * 0.78;
  if (player && player.y > floorY) player.y = floorY;
}
window.addEventListener('resize', resizeCanvas);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeCanvas);

/* ---------- Game state ---------- */
let W = 960, H = 540;
let floorY = H * 0.78;

const world = {
  speed: 8,
  baseSpeed: 8,
  maxSpeed: 20,
  score: 0,
  alive: false,
  spawnDist: 600,     // start gap
  gapMin: 520,
  gapMax: 760,
  rampK: 0.020        // speed increases by score only
};

const player = { x: 120, y: floorY, vy: 0, w: 120, h: 80, onGround: true };
const obstacles = [];
const TRI_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#8338ec','#ef476f','#f9c74f','#90be6d'];

const gravity = 0.9;
const JUMP_VEL_1 = -14.5;
const JUMP_VEL_2 = -12.2;
const COYOTE_FRAMES = 8;
const BUFFER_FRAMES = 10;

let coyote = 0, jumpBuffer = 0, usedDouble = false;

/* ---------- Vespa sprite ---------- */
const vespaImg = new Image();
let vespaReady = false;
vespaImg.onload = () => vespaReady = true;
vespaImg.src = 'Blue Vespa Right.png'; // must exist next to index.html

/* ---------- UI refs ---------- */
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

const scoreboard = document.getElementById('scoreboard');
const finalScoreEl = document.getElementById('finalScore');
const initialsEl = document.getElementById('playerName');
const submitBtn = document.getElementById('submitScore');
const skipBtn = document.getElementById('skipBtn');
const goRestartBtn = document.getElementById('goRestartBtn');
const lbEl = document.getElementById('lb');
const lbSub = document.getElementById('lbSub');

/* ---------- Leaderboard API ---------- */
const API = 'https://scooter-game-api.vercel.app';
async function getTop10(){
  try{
    const r = await fetch(`${API}/api/leaderboard`, { cache: 'no-store' });
    if(!r.ok) return [];
    return await r.json();
  } catch { return []; }
}
async function saveScore(name, score){
  const r = await fetch(`${API}/api/leaderboard`, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ name, score })
  });
  const txt = await r.text();
  let data = null; try{ data = txt ? JSON.parse(txt) : null; }catch{}
  if(!r.ok) throw new Error(data?.error || txt || 'save failed');
  return data;
}
function renderLB(list){
  lbEl.innerHTML = '';
  list.forEach((e,i)=>{
    const li = document.createElement('li');
    const name = (e.name||'---').toUpperCase().slice(0,3);
    li.innerHTML = `<span>${i+1}.) ${name}</span><span>${e.score}</span>`;
    lbEl.appendChild(li);
  });
  lbSub.textContent = list.length ? 'Global leaderboard' : 'No scores yet ‚Äî be the first!';
}

/* ---------- Game control ---------- */
function reset(){
  world.score = 0;
  world.speed = world.baseSpeed;
  world.spawnDist = 600;
  obstacles.length = 0;
  player.x = Math.max(120, 0.18 * W);
  player.y = floorY; player.vy = 0; player.onGround = true;
  coyote = 0; jumpBuffer = 0; usedDouble = false;
}
function startGame(){
  reset();
  world.alive = true;
  startBtn.style.display = 'none';
  restartBtn.style.display = 'none';
  scoreboard.style.display = 'none';
}
function endGame(){
  world.alive = false;
  finalScoreEl.textContent = Math.floor(world.score);
  initialsEl.value = '';
  scoreboard.style.display = 'flex';
  // Load Top 10 for the overlay
  lbSub.textContent = 'Loading‚Ä¶';
  getTop10().then(renderLB);
}

/* ---------- Input: keyboard ---------- */
document.addEventListener('keydown', (e)=>{
  if(e.code === 'Space' || e.keyCode === 38){
    e.preventDefault();
    if (!world.alive) { startGame(); return; }
    jumpBuffer = BUFFER_FRAMES;
  } else if(e.code === 'KeyR'){
    e.preventDefault();
    startGame();
  }
});

/* ---------- Input: tap (canvas only, don‚Äôt block overlay) ---------- */
canvas.addEventListener('pointerdown', (e)=>{
  if(e.pointerType === 'mouse') return;
  if(!world.alive){ e.preventDefault(); startGame(); return; }
  e.preventDefault(); jumpBuffer = BUFFER_FRAMES;
}, { passive:false });
canvas.addEventListener('touchstart', (e)=>{
  if(!world.alive){ e.preventDefault(); startGame(); return; }
  e.preventDefault(); jumpBuffer = BUFFER_FRAMES;
}, { passive:false });

/* ---------- Start/Restart buttons: click + pointer + touch ---------- */
function startFromUI(e){ if(e) e.preventDefault(); startGame(); }
function restartFromUI(e){ if(e) e.preventDefault(); startGame(); }

startBtn.addEventListener('click', startFromUI);
startBtn.addEventListener('pointerdown', startFromUI, { passive:false });
startBtn.addEventListener('touchstart', startFromUI, { passive:false });

restartBtn.addEventListener('click', restartFromUI);
restartBtn.addEventListener('pointerdown', restartFromUI, { passive:false });
restartBtn.addEventListener('touchstart', restartFromUI, { passive:false });

goRestartBtn.addEventListener('click', restartFromUI);
goRestartBtn.addEventListener('pointerdown', restartFromUI, { passive:false });
goRestartBtn.addEventListener('touchstart', restartFromUI, { passive:false });

/* ---------- Initials input constraints ---------- */
function sanitizeInitials(s){ return (s||'').toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,3); }
initialsEl.addEventListener('input', ()=>{
  const clean = sanitizeInitials(initialsEl.value);
  if(initialsEl.value !== clean) initialsEl.value = clean;
});

/* ---------- Save / Skip ---------- */
submitBtn.addEventListener('click', async ()=>{
  const name = sanitizeInitials(initialsEl.value);
  if(!name) { scoreboard.style.display='none'; return; }
  try{
    submitBtn.textContent = 'Saving‚Ä¶';
    submitBtn.disabled = true;
    await saveScore(name, Math.floor(world.score));
    const lb = await getTop10(); renderLB(lb);
  }catch(err){
    alert('Save failed: ' + (err.message || err));
  }finally{
    submitBtn.textContent = 'Save';
    submitBtn.disabled = false;
  }
});
skipBtn.addEventListener('click', ()=>{ scoreboard.style.display='none'; });

/* ---------- Spawning & gameplay ---------- */
function randInt(a,b){ return (a + Math.random()*(b-a))|0; }
function planNextSpawn(){ world.spawnDist = randInt(world.gapMin, world.gapMax); }
function spawnTriangle(){
  const base  = 38 + Math.random()*48;
  const high  = 44 + Math.random()*90;
  const color = TRI_COLORS[(Math.random()*TRI_COLORS.length)|0];
  obstacles.push({ x: W + 40, y: floorY, base, height: high, color });
}

function getPlayerBounds(){
  return { x: player.x - player.w*0.45, y: player.y - player.h, w: player.w*0.9, h: player.h*0.95 };
}
function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

function update(){
  // Speed ramp (difficulty) only by score
  world.speed = Math.min(world.maxSpeed, world.baseSpeed + world.score * world.rampK);

  if(world.alive){
    // Coyote + buffered jump + double jump
    if(player.onGround) coyote = COYOTE_FRAMES; else if(coyote>0) coyote--;
    if(jumpBuffer>0) jumpBuffer--;
    if(jumpBuffer>0 && (player.onGround || coyote>0)){
      player.vy = JUMP_VEL_1; player.onGround=false; usedDouble=false; jumpBuffer=0;
    } else if(jumpBuffer>0 && !player.onGround && !usedDouble){
      player.vy = JUMP_VEL_2; usedDouble=true; jumpBuffer=0;
    }

    // Gravity
    player.vy += gravity; player.y += player.vy;
    if(player.y >= floorY){ player.y = floorY; player.vy = 0; if(!player.onGround){ player.onGround=true; usedDouble=false; } }
    else { player.onGround = false; }

    // Move obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i]; o.x -= world.speed; if(o.x + o.base < -120) obstacles.splice(i,1);
    }

    // Distance-based spawn (single triangle per cycle)
    world.spawnDist -= world.speed;
    if(world.spawnDist <= 0){ spawnTriangle(); planNextSpawn(); }

    // Score over time (slightly boosted by speed)
    world.score += 0.24 + world.speed*0.013;

    // Collision (AABB vs triangle bbox)
    const pb = getPlayerBounds();
    for(const o of obstacles){
      const ob = { x:o.x, y:o.y - o.height, w:o.base, h:o.height };
      if(rectsOverlap(pb, ob)){ endGame(); break; }
    }
  }

  draw();
  requestAnimationFrame(update);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Background sky
  ctx.fillStyle = '#a6d4ff';
  ctx.fillRect(0, 0, W, H);

  // Road
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(0, floorY, W, H - floorY);
  ctx.fillStyle = 'rgba(255,255,255,.25)';
  const stripeW=120, stripeH=6, phase=(world.score*0.5)%(stripeW*2);
  for(let x=-phase; x<W; x+=stripeW*2){
    const xx1=Math.round(x), xx2=Math.round(x+60);
    ctx.fillRect(xx1, floorY+30, stripeW, stripeH);
    ctx.fillRect(xx2, floorY+60, stripeW, stripeH);
  }

  // Obstacles (triangles)
  for(const o of obstacles){
    ctx.fillStyle = o.color; ctx.beginPath();
    const x0=Math.round(o.x), y0=Math.round(o.y);
    const x1=Math.round(o.x + o.base/2), y1=Math.round(o.y - o.height);
    const x2=Math.round(o.x + o.base);
    ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y0); ctx.closePath(); ctx.fill();
  }

  // Player: draw Vespa PNG (fallback to blue rect if not loaded yet)
  if (vespaReady) {
    ctx.drawImage(
      vespaImg,
      Math.round(player.x - player.w/2),
      Math.round(player.y - player.h),
      player.w,
      player.h
    );
  } else {
    ctx.fillStyle = '#1e8bff';
    ctx.fillRect(Math.round(player.x - player.w/2), Math.round(player.y - player.h), player.w, player.h);
  }

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,.16)';
  ctx.beginPath();
  ctx.ellipse(player.x, player.y-2, player.w*0.44, 8, 0, 0, Math.PI*2);
  ctx.fill();

  // HUD (score)
  ctx.fillStyle = '#111';
  ctx.font = '16px system-ui, sans-serif';
  ctx.fillText(`Score: ${Math.floor(world.score)}`, 12, 22);
}

/* ---------- Kickoff ---------- */
resizeCanvas();
requestAnimationFrame(update);
</script>
</body>
</html>