<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vespa Jump</title>
<style>
  :root { --sky:#cfe9ff; --road:#2a2a2a; --ink:#111; }
  html,body{height:100%;margin:0;background:var(--sky);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #page{display:grid;grid-template-rows:auto 1fr;min-height:100vh}
  .board{padding:8px 12px 0 12px}
  .board h2{margin:6px 0 4px 0;font-size:15px}
  .board ol{margin:0;padding-left:18px;display:grid;gap:2px;max-width:960px}
  .board li{font-weight:700;color:var(--ink);display:flex;justify-content:space-between}
  .board .muted{opacity:.65;font-weight:600}
  #wrap{display:grid;place-items:center}
  canvas{background:linear-gradient(#cfe9ff,#a6d4ff 60%);box-shadow:0 10px 40px rgba(0,0,0,.25);border-radius:14px;width:960px;height:540px;touch-action:manipulation}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.85);text-align:center;z-index:10}
  .card{background:#fff;border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.2);padding:20px 28px;min-width:320px;max-width:92vw}
  .btn{display:inline-block;background:#111;color:#fff;padding:10px 16px;border-radius:10px;font-weight:800;margin-top:10px;text-decoration:none}
  kbd{background:#111;color:#fff;border-radius:6px;padding:3px 6px;font-weight:700}
  .row{display:flex;gap:10px;justify-content:center;margin-top:10px;flex-wrap:wrap}
  .field{display:flex;justify-content:center;gap:8px;margin-top:10px}
  input.initials{font-size:28px;text-transform:uppercase;letter-spacing:6px;width:140px;text-align:center;
    padding:8px 10px;border:2px solid #111;border-radius:10px;outline:none}
  .hint{font-size:12px;color:#444;margin-top:6px}
  body { -webkit-tap-highlight-color: transparent; }

/* Mobile: canvas fills the real visible height */
@media (max-width: 768px){
  /* Hide the top board during play; we‚Äôll show a copy in Game Over */
  #page{ grid-template-rows: 0 1fr; }
  .board{ display:none; }

  /* The height uses a JS-updated variable that matches the real viewport */
  canvas{
    width: 100vw;
    height: calc(var(--app-vh, 100vh) - 16px);
    max-width: 100%;
    max-height: 100%;
    aspect-ratio: auto;
  }

  /* If overlays are taller than the screen, allow scrolling so buttons aren‚Äôt cut off */
  .overlay{
    align-items: flex-start;
    overflow: auto;
    padding: 16px 0;
  }
  .card{ margin: auto; }
}
</style>
</head>
<body>
<div id="page">
  <!-- Desktop/large: visible. Mobile: hidden during gameplay (we show a copy at Game Over) -->
  <div class="board" id="topBoard">
    <h2>üèÅ Top 10 Scores</h2>
    <ol id="lb"></ol>
    <div class="muted" id="lbSub">Loading‚Ä¶</div>
  </div>

  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="Vespa Jump game"></canvas>
  </div>
</div>

<div id="startScreen" class="overlay">
  <div class="card">
    <h1 style="margin:0 0 8px">üõµ Vespa Jump</h1>
    <div>Tap, press <kbd>Space</kbd> or <kbd>‚Üë</kbd> to jump. Tap/press again mid‚Äëair for a double jump.<br/>After a crash, press <kbd>R</kbd> or tap <em>Restart</em>.</div>
    <a href="#" id="startBtn" class="btn">Start</a>
  </div>
</div>

<div id="gameOver" class="overlay" style="display:none">
  <div class="card">
    <h2 style="margin:0 8px 8px">Game Over</h2>
    <div style="margin-bottom:8px">Score: <span id="finalScore">0</span> ¬∑ Best: <span id="finalBest">0</span></div>

    <!-- Initials entry -->
    <div id="qualifyBox" style="display:none">
      <div class="field">
        <input id="initials" class="initials" maxlength="3" placeholder="AAA" autocomplete="off" spellcheck="false">
      </div>
      <div class="hint">Enter 3 letters/numbers ¬∑ Only A‚ÄìZ / 0‚Äì9</div>
      <div class="row">
        <a href="#" id="saveScoreBtn" class="btn">Save</a>
        <a href="#" id="skipBtn" class="btn" style="background:#666">Skip</a>
      </div>
    </div>

    <!-- Mobile-only: show Top 10 here so you don‚Äôt scroll up -->
    <div id="lbGO" style="display:none; margin-top:14px; text-align:left">
      <div style="font-weight:800;margin-bottom:6px">üèÅ Top 10</div>
      <ol id="lb2" style="margin:0;padding-left:18px;display:grid;gap:2px;max-height:38vh;overflow:auto"></ol>
    </div>

    <div class="row" id="restartRow">
      <a href="#" id="restartBtn" class="btn">Restart (R)</a>
    </div>
  </div>
</div>

<script>
/* ===== Same-origin API ===== */
async function apiGetTop10(){
  try{
    const r = await fetch('/api/leaderboard', { cache: 'no-store' });
    if(!r.ok) return [];
    return await r.json();
  }catch{ return []; }
}
async function apiSaveScore(name, score){
  const r = await fetch('/api/leaderboard', {
    method:'POST',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify({ name, score })
  });
  const text = await r.text();
  let data = null; try { data = text ? JSON.parse(text) : null; } catch {}
  if(!r.ok) throw new Error(data?.error || text || 'save failed');
  return data;
}

/* ===== HiDPI Canvas ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:true });
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
// --- Real mobile viewport height -> CSS var --app-vh
function setAppVh() {
  const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
  document.documentElement.style.setProperty('--app-vh', vh + 'px');
}
setAppVh();
addEventListener('resize', setAppVh);
addEventListener('orientationchange', setAppVh);
if (window.visualViewport) window.visualViewport.addEventListener('resize', setAppVh);
function resizeCanvas(){
  // Use the element‚Äôs rendered size (after CSS sets height/width)
  const rect = canvas.getBoundingClientRect();
  const cssW = Math.max(1, Math.floor(rect.width));
  const cssH = Math.max(1, Math.floor(rect.height));

  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width  = cssW * DPR;
  canvas.height = cssH * DPR;

  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = true;
}
setAppVh();   // ensure var is set before first measurement
resizeCanvas();
addEventListener('resize', resizeCanvas);
resizeCanvas(); addEventListener('resize', resizeCanvas);

/* ===== UI refs ===== */
const startScreen = document.getElementById('startScreen');
const gameOverEl  = document.getElementById('gameOver');
const startBtn    = document.getElementById('startBtn');
const restartBtn  = document.getElementById('restartBtn');
const finalScore  = document.getElementById('finalScore');
const finalBest   = document.getElementById('finalBest');
const qualifyBox  = document.getElementById('qualifyBox');
const initialsEl  = document.getElementById('initials');
const saveScoreBtn= document.getElementById('saveScoreBtn');
const skipBtn     = document.getElementById('skipBtn');
const topBoard    = document.getElementById('topBoard');
const lbEl        = document.getElementById('lb');
const lbSub       = document.getElementById('lbSub');
const lbGO        = document.getElementById('lbGO');
const lb2El       = document.getElementById('lb2');

/* ===== Sprite (PNG) ===== */
const vespaImg = new Image();
vespaImg.src = 'Blue Vespa Right.png';
let vespaReady = false; vespaImg.onload = ()=> vespaReady = true;

/* ===== Physics / Tuning ===== */
const W = 960, H = 540;
const floorY = H * 0.78;
const gravity = 0.9;
const JUMP_VEL_1 = -14.5, JUMP_VEL_2 = -12.2;
const COYOTE_FRAMES = 8, BUFFER_FRAMES = 10;

/* ===== World ‚Äî difficulty by speed only; generous spacing ===== */
const world = {
  t: 0,
  speed: 8,
  baseSpeed: 8,
  maxSpeed: 20,
  score: 0,
  best: Number(localStorage.getItem('vespa_best') || 0),
  alive: false,

  // Fixed comfortable spacing (pixels). No tightening over time.
  gapMin: 520,
  gapMax: 760,
  spawnDist: 520,

  // Difficulty only via speed ramp:
  rampK: 0.020
};
function effectiveSpeed(){ return Math.min(world.maxSpeed, world.baseSpeed + world.score * world.rampK); }

/* ===== Input ===== */
const keys = { up:false, space:false };
const KEY  = { UP:38, SPACE:32, R:82 };

/* ===== Player ===== */
const PLAYER_W = 120, PLAYER_H = 80;
const player = { x: W*0.18, y: floorY, vy: 0, w: PLAYER_W, h: PLAYER_H, onGround: true, jumps: 0, coyote: 0, jumpBuffer: 0, usedDouble: false };

/* ===== Obstacles (triangles) ===== */
const TRI_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#8338ec','#ef476f','#f9c74f','#90be6d'];
const obstacles = [];
function randInt(a,b){ return (a + Math.random()*(b-a))|0; }
function spawnTriangleAt(x){
  const base  = 38 + Math.random()*48;
  const high  = 44 + Math.random()*90;
  const color = TRI_COLORS[(Math.random()*TRI_COLORS.length)|0];
  obstacles.push({ x, y: floorY, base, height: high, color });
}
function planNextSpawn(){ world.spawnDist = randInt(world.gapMin, world.gapMax); }

/* ===== Leaderboard (render to top bar or to Game Over card) ===== */
async function renderLB(targetOl = lbEl){
  const lb = (await apiGetTop10()) || [];
  targetOl.innerHTML = '';
  lb.forEach((e,i)=>{
    const li = document.createElement('li');
    const name = (e.name||'---').toUpperCase().slice(0,3);
    li.innerHTML = `<span>${i+1}.) ${name}</span><span>${e.score}</span>`;
    targetOl.appendChild(li);
  });
  if(targetOl === lbEl) lbSub.textContent = lb.length ? 'Global leaderboard' : 'No scores yet ‚Äî be the first!';
}
// Initial render for desktop / large screens
renderLB();

/* ===== State helpers ===== */
function hardResetInput(){ keys.up=false; keys.space=false; player.jumpBuffer=0; }
function resetGame(){
  world.t=0; world.score=0;
  world.speed = world.baseSpeed;
  world.gapMin = 520; world.gapMax = 760; world.spawnDist = 520;
  player.y=floorY; player.vy=0; player.onGround=true;
  player.jumps=0; player.usedDouble=false; player.coyote=0; player.jumpBuffer=0;
  obstacles.length=0; hardResetInput();
}
function startGame(){
  resetGame(); world.alive = true;
  startScreen.style.display='none'; gameOverEl.style.display='none';
  // On mobile, keep top board hidden during play (CSS handles it),
  // but if it was shown in last Game Over, hide the GO leaderboard copy:
  lbGO.style.display = 'none';
}
let awaitingInitials = false;

/* ===== Game over & save flow ===== */
function gameOver(){
  world.alive = false;
  finalScore.textContent = Math.floor(world.score);
  if(world.score > world.best){ world.best = Math.floor(world.score); localStorage.setItem('vespa_best', world.best); }
  finalBest.textContent = world.best;

  (async()=>{
    // Decide if qualifies
    const lb = (await apiGetTop10()) || [];
    const minToBeat = lb.length < 10 ? 0 : (lb[9]?.score || 0);
    const qualifies = Math.floor(world.score) > minToBeat || lb.length < 10;
    qualifyBox.style.display = qualifies ? 'block' : 'none';
    awaitingInitials = qualifies;
    initialsEl.value = '';

    // On small screens, show a compact Top 10 inside the card
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if(isMobile){
      lbGO.style.display = 'block';
      await renderLB(lb2El);
    } else {
      lbGO.style.display = 'none';
      await renderLB(lbEl);
    }

    gameOverEl.style.display='flex';
    if(qualifies) setTimeout(()=>initialsEl.focus(), 80);
  })();

  hardResetInput();
}

/* ===== Keyboard ===== */
function keyHandler(e, down){
  if(e.keyCode===KEY.SPACE || e.keyCode===KEY.UP){
    if(down) e.preventDefault();
    if(e.keyCode===KEY.SPACE) keys.space = down; else keys.up = down;
    if(down && !world.alive && !awaitingInitials){ startGame(); return; }
    if(down && world.alive){ player.jumpBuffer = BUFFER_FRAMES; }
  } else if(e.keyCode===KEY.R && down){
    doRestartFlow();
  }
}
addEventListener('keydown', e=>keyHandler(e,true));
addEventListener('keyup',   e=>keyHandler(e,false));
startBtn.addEventListener('click', e=>{ e.preventDefault(); startGame(); });

/* ===== Tap/Touch (canvas-only, don‚Äôt steal overlay taps) ===== */
const tapSurface = canvas;
function handleTap(){ if(!world.alive && !awaitingInitials){ startGame(); return; } if(world.alive){ player.jumpBuffer = BUFFER_FRAMES; } }
function onCanvasPointerDown(e){
  if(e.pointerType === 'mouse') return;
  if(gameOverEl.style.display === 'flex') return;
  if(startScreen.style.display !== 'none'){ e.preventDefault(); handleTap(); return; }
  if(awaitingInitials) return;
  e.preventDefault(); handleTap();
}
function onCanvasTouchStart(e){
  if(gameOverEl.style.display === 'flex' || awaitingInitials) return;
  if(e.touches && e.touches.length === 1){ e.preventDefault(); handleTap(); }
}
tapSurface.addEventListener('pointerdown', onCanvasPointerDown, { passive:false });
tapSurface.addEventListener('touchstart',  onCanvasTouchStart,  { passive:false });
// stop overlay UI from bubbling to canvas
[initialsEl, saveScoreBtn, skipBtn, restartBtn, startBtn].forEach(el=>{
  if(!el) return;
  el.addEventListener('pointerdown', e=>e.stopPropagation(), { passive:true });
  el.addEventListener('touchstart',  e=>e.stopPropagation(), { passive:true });
});

/* ===== Initials constraints + Save/Skip/Restart ===== */
function sanitizeInitials(s){ return (s||'').toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,3); }
initialsEl.addEventListener('input', ()=>{
  const clean = sanitizeInitials(initialsEl.value);
  if(initialsEl.value !== clean) initialsEl.value = clean;
});
function setSaving(state){
  saveScoreBtn.textContent = state ? 'Saving‚Ä¶' : 'Save';
  saveScoreBtn.style.opacity = state ? '.7' : '1';
  saveScoreBtn.style.pointerEvents = state ? 'none' : 'auto';
}
async function trySaveIfNeeded(){
  const name = sanitizeInitials(initialsEl.value);
  if(!awaitingInitials) return true;
  if(name.length < 1) return true;
  try{
    setSaving(true);
    await apiSaveScore(name, Math.floor(world.score));
    await renderLB(lbEl); // refresh desktop bar for when user returns there
    return true;
  }catch(err){
    alert('Save failed: ' + (err.message || err));
    return false;
  }finally{
    setSaving(false);
  }
}
async function doRestartFlow(){ await trySaveIfNeeded(); awaitingInitials=false; startGame(); }
saveScoreBtn.addEventListener('click', async e=>{ e.preventDefault(); await doRestartFlow(); });
skipBtn     .addEventListener('click', async e=>{ e.preventDefault(); awaitingInitials=false; startGame(); });
restartBtn  .addEventListener('click', async e=>{ e.preventDefault(); await doRestartFlow(); });

/* ===== Gameplay ===== */
function handlePlayerControls(){
  if(player.onGround) player.coyote = COYOTE_FRAMES; else if(player.coyote>0) player.coyote--;
  if(player.jumpBuffer>0) player.jumpBuffer--;
  if(player.jumpBuffer>0 && (player.onGround || player.coyote>0)){
    player.vy = JUMP_VEL_1; player.onGround=false; player.jumps=1; player.usedDouble=false; player.jumpBuffer=0;
  } else if(player.jumpBuffer>0 && !player.onGround && !player.usedDouble){
    player.vy = JUMP_VEL_2; player.usedDouble=true; player.jumps=2; player.jumpBuffer=0;
  }
}
function update(){
  world.t++;
  if(world.alive){
    world.speed = effectiveSpeed();

    handlePlayerControls();

    // Physics
    player.vy += gravity; player.y += player.vy;
    if(player.y >= floorY){
      player.y = floorY; player.vy = 0;
      if(!player.onGround){ player.onGround=true; player.usedDouble=false; player.jumps=0; }
    } else { player.onGround = false; }

    // Move obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i]; o.x -= world.speed;
      if(o.x + o.base < -120) obstacles.splice(i,1);
    }

    // Spawning ‚Äî single triangle per spawn (no back-to-back)
    world.spawnDist -= world.speed;
    if(world.spawnDist <= 0){
      spawnTriangleAt(W + 40);
      planNextSpawn();
    }

    // Scoring
    world.score += 0.24 + world.speed*0.013;

    // Collision (AABB vs triangle bbox)
    const pb = getPlayerBounds();
    for(const o of obstacles){
      const ob = { x:o.x, y:o.y - o.height, w:o.base, h:o.height };
      if(rectsOverlap(pb, ob)){ gameOver(); break; }
    }
  }
  draw();
  requestAnimationFrame(update);
}

/* ===== Utils / Drawing ===== */
function getPlayerBounds(){ return { x: player.x - player.w*0.45, y: player.y - player.h, w: player.w*0.9, h: player.h*0.95 }; }
function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function drawRoad(){
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, floorY, W, H-floorY);
  ctx.fillStyle = 'rgba(255,255,255,.25)';
  const stripeW=120, stripeH=6, phase=(world.t*world.speed*0.5)%(stripeW*2);
  for(let x=-phase; x<W; x+=stripeW*2){
    const xx1=Math.round(x), xx2=Math.round(x+60);
    ctx.fillRect(xx1, floorY+30, stripeW, stripeH);
    ctx.fillRect(xx2, floorY+60, stripeW, stripeH);
  }
}
function drawTriangles(){
  for(const o of obstacles){
    ctx.fillStyle=o.color; ctx.beginPath();
    const x0=Math.round(o.x), y0=Math.round(o.y);
    const x1=Math.round(o.x+o.base/2), y1=Math.round(o.y-o.height);
    const x2=Math.round(o.x+o.base);
    ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y0); ctx.closePath(); ctx.fill();
  }
}
function drawVespa(){
  if(vespaReady){
    ctx.drawImage(vespaImg, Math.round(player.x - player.w/2), Math.round(player.y - player.h), player.w, player.h);
  }else{
    ctx.fillStyle = '#1e8bff';
    ctx.fillRect(Math.round(player.x - player.w/2), Math.round(player.y - player.h), player.w, player.h);
  }
  ctx.fillStyle = 'rgba(0,0,0,.16)';
  ctx.beginPath(); ctx.ellipse(player.x, player.y-2, player.w*0.44, 8, 0, 0, Math.PI*2); ctx.fill();
}
function draw(){ ctx.clearRect(0,0,W,H); drawRoad(); drawTriangles(); drawVespa(); }

update();
</script>
</body>
</html>